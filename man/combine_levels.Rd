% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{combine_levels}
\alias{combine_levels}
\alias{combine_regex}
\title{Combine values}
\usage{
combine_levels(
  x,
  levels,
  labels = NULL,
  ordered = is.ordered(x),
  regex = FALSE,
  ...
)

combine_regex(
  x,
  levels,
  labels = NULL,
  ordered = is.ordered(x),
  keep.original = TRUE,
  ...
)
}
\arguments{
\item{x}{a vector}

\item{levels}{for \code{combine_levels}, a vector of unique values of
\code{x} to combine; to combine values into multiple groups, use a list

for \code{combine_regex} (or \code{combine_labels(..., regex = TRUE)}),
a vector of regular expressions; if a list is given, each list element
will be collapsed with an "or" statement and treated as single expressions

for values of \code{x} which match none of \code{levels} and if
\code{keep.original = FALSE}, a \emph{named} \code{NULL} list element can
group these values; otherwise, the smallest unused integer is used; see
examples}

\item{labels}{for \code{combine_levels}, a vector of new labels; if
\code{levels} is a vector, \code{labels} should be length 1; if
\code{levels} is a list, \code{labels} (need not be a list but) should
have one value for each list element of \code{levels}

for \code{combine_regex}, if \code{keep.original = FALSE}, one additional
label should be given for values that do not match any of \code{levels}}

\item{ordered}{logical; if \code{TRUE}, returns an ordered factor}

\item{regex}{logical; if \code{TRUE}, \code{levels} is assumed to be
regular expressions, and inputs are passed to \code{combine_regex}}

\item{...}{additional arguments passed to \code{combine_regex} or further
to \code{\link{grep}}}

\item{keep.original}{deprecated, will be ignored}
}
\value{
\code{combine_levels} will always return a factor. The levels will be
in the order of \code{x} plus any new levels (i.e., \code{labels}).

\code{combine_regex} returns an integer vector if character \code{labels}
are not given; otherwise, a character vector is returned.
}
\description{
Convenience functions to combine multiple levels of a vector into a new or
existing level(s). \code{combine_levels} and \code{combine_regex} are
similar in use, but the latter is more useful for unstructured text which
can be grouped by regular expressions.
}
\examples{
## combine numeric, character, or factor
x <- rep(1:3, each = 2)
combine_levels(x, 1:2, 1)
combine_levels(x, list(1:2, 3), c('a', 'b'))

## use a named list to get the same as above
combine_levels(x, list(a = 1:2, b = 3))

## use NULL list to combine others
combine_levels(x, list(b = 3, others = NULL))

## levels may be swapped without losing original distinction
combine_levels(x, list('3' = 1:2, '1' = 3))
combine_levels(x, list('1' = 3, '3' = 1:2))


## combine by regular expression
x <- letters[1:5]
combine_regex(x, 'a')
combine_regex(x, c('a', 'b'))
combine_regex(x, c('a', 'b|c|e'))

## character labels return a labeled factor
combine_regex(x, 'a', c('a', 'b'))            ## a -> a; else -> b
combine_regex(x, '[a-c]', c('ABC', 'Others')) ## a,b,c -> ABC; else Others

## levels passed as a list
combine_regex(x, list(ABC = c('a', 'b', 'c')))       ## d,e are unchanged
combine_regex(x, list(ABC = '[a-c]', Others = NULL)) ## d,e are changed

## combine_levels(..., regex = TRUE) returns the same as above
combine_levels(x, '[a-c]', c('ABC', 'Others'), regex = TRUE)

}
\seealso{
\code{\link{factor2}}; \code{\link[rawr2]{recoder}}
}
