% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zxx.R
\name{cumfuns}
\alias{cumfuns}
\alias{cum_reset}
\alias{cum_na}
\alias{cumsum_na}
\alias{cumprod_na}
\alias{cummax_na}
\alias{cummin_na}
\alias{cum_mid}
\title{Cumulative functions}
\usage{
cum_reset(x, value = 0L, FUN)

cum_na(x, FUN, useNA = TRUE)

cumsum_na(x, useNA = TRUE)

cumprod_na(x, useNA = TRUE)

cummax_na(x, useNA = TRUE)

cummin_na(x, useNA = TRUE)

cum_mid(x, adj = 0.5)
}
\arguments{
\item{x}{a vector (or numeric matrix for \code{cum_mid})}

\item{value}{a value of \code{x} which signals the end of a group and
resets \code{FUN}}

\item{FUN}{function to apply to each group, usually one of
\code{\link{cumsum}}, \code{\link{cumprod}}, \code{\link{cummax}}, or
\code{\link{cummin}} but can be any function that returns a vector the
same length and type as the input (\emph{a la} \code{\link{ave}})}

\item{useNA}{logical; if \code{TRUE}, indices with \code{NA} will be
unchanged; if \code{FALSE}, the previous value is carried forward}

\item{adj}{for \code{cum_mid}, an adjustment parameter, usually in
\code{[0, 1]}, giving the relative position between each value (default
is centered, \code{adj = 0.5})}
}
\value{
A vector having the same length as \code{x} with \code{FUN} applied to
each group defined by positions of \code{value}.
}
\description{
\code{cum_reset} will reset a cumulative function, \code{FUN}, when
\code{value} is encountered.

\code{*_na} functions offer alternatives to the \pkg{base}
\link[=cumsum]{cumulative functions} that can handle \code{NA}s.

\code{cum_mid} finds the mid-points between "stacked" numeric values.
}
\examples{
x <- 1:10
cum_reset(x, 5, cummin)
cum_reset(x, c(5, 8), cummin)

x[x \%\% 4 == 0] <- 0
cum_reset(x, FUN = cumsum)
cum_reset(x, FUN = sum)

set.seed(1)
data.frame(x = x <- rpois(15, 1),
           y = cum_reset(x, FUN = cumsum),
           z = cum_reset(x, 0, function(x) ave(x, FUN = sum)))


## x need not be numeric if FUN returns an appropriate type and length
cum_reset(letters[1:10], c('d','g'), function(x)
  letters[as.numeric(factor(x))])


## cum* functions to handle NA values
x <- 1:10
x[x \%\% 4 == 0] <- 0
na <- ifelse(x == 0, NA, x)

cumsum(x)
cum_na(x, cumsum)

cumsum(na)
cum_na(na, cumsum)

## shorthand
cumsum_na(na)
cumsum_na(na)


## like cum_reset, cum_na's FUN argument can be generalized if FUN
## returns the correct class and length of the input
FUN <- function(x) vector(class(x), length(x))
cum_na(na, FUN)

cumdiff <- function(x) Reduce(`-`, x, accumulate = TRUE)
cumdiff(x)
cumsum(c(x[1L], -x[-1L]))

cumdiff(na)
cumsum(c(na[1L], -na[-1L]))
cum_na(na, cumdiff)


## "stacked" numeric values, eg, from a barplot
set.seed(1)
x <- matrix(runif(12), ncol = 3L)
bp <- barplot(x, names.arg = paste('adj = ', c(0, 1, 0.5)))

for (ii in seq.int(ncol(x))) {
  xii <- x[, ii, drop = FALSE]
  text(bp[ii], cum_mid(xii, c(0, 1, 0.5)[ii]), xii, xpd = NA)
}

}
\seealso{
\code{\link{cumsum}}; \code{\link{ave}}; \code{locf}
}
