% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{bindx}
\alias{bindx}
\alias{bind_all}
\alias{cbindx}
\alias{rbindx}
\alias{rbindfill}
\alias{rbindfill2}
\alias{rbindlist}
\alias{rbindlist2}
\title{Bind objects}
\usage{
bind_all(..., which)

cbindx(..., deparse.level = 1L)

rbindx(..., deparse.level = 1L)

rbindfill(...)

rbindfill2(..., use.rownames = FALSE)

rbindlist(..., use.rownames = FALSE, use.names = FALSE)

rbindlist2(
  data,
  column,
  split = "\\\\W+",
  fixed = FALSE,
  perl = FALSE,
  use.rownames = any(rownames(data) != seq.int(nrow(data)))
)
}
\arguments{
\item{...}{for \code{bind_all} and \code{rbindfill}, vectors;
\code{cbindx} and \code{rbindx} will accept vectors, matrices, data
frames; data frames should be used with \code{rbindfill2} but matrices
(or a combination) will work, but a data frame is returned;
\code{rbindlist} accepts vectors or one or more lists}

\item{which}{joining method; \code{'rbind'} or \code{'cbind'}}

\item{deparse.level}{integer controlling the construction of labels in
the case of non-matrix-like arguments (for the default method):\cr
\code{deparse.level = 0} constructs no labels; the default; \cr
\code{deparse.level = 1} or \code{2} constructs labels from the argument
names \cr see \code{\link{cbind}}}

\item{use.rownames}{logical; for \code{rbindfill2}, if \code{TRUE}, data
  frames in a \emph{named} list will retain corresponding rownames; the
  default is to remove rownames (note that this parameter is ignored if
  \code{...} is not a named list)

  for \code{rbindlist} and \code{rbindlist2}, return a data frame with or
  without rownames; for \code{rbindlist2}, if \code{data} has no row names
  set (i.e., are \code{"1", "2", ...}), then the default is \code{FALSE}}

\item{use.names}{logical; if \code{TRUE} and vectors are named, names
are preserved and added as a column}

\item{data}{a matrix or data frame}

\item{column}{for \code{rbindlist2}, the column(s) to be unnested}

\item{split, fixed, perl}{arguments passed to \code{\link{strsplit}}
controlling how nested column text should be split}
}
\description{
Utilities for binding objects with inconsistent dimensions.
}
\details{
\code{bind_all} and \code{rbindfill} are used for binding vectors,
the latter specifically for \code{\link{rbind}}ing \emph{named} vectors
\emph{a la} a "stacking" merge.

\code{cbindx} and \code{rbindx} take vector-, matrix-, and data frame-like
objects and bind normally, filling with \code{NA}s where dimensions are
not equal.

\code{rbindfill} stacks \emph{named} vectors by initializing a matrix
with all names and filling with \code{...} by row in the order given.
The column names will be a vector of the unique names in the order they
were given.

\code{rbindfill2} row-binds data frames with zero or more common column
names. \code{rbindfill2} starts with the first data frame given and
\code{rbind}s subsequent data frames adding new columns of \code{NA} as
needed to bind. Any columns with matching names will be aggregated;
otherwise, data frames without a matching column of data will be filled
with \code{NA}.

\code{rbindlist} converts a list of vectors into a long data frame with
two columns: the list index where each value was stored and the values
themselves. A third column will be added if \code{use.names = TRUE} which
will keep the names of each vector.

\code{rbindlist2} uses \code{rbindlist} to expand data frames with one or
more nested columns.
}
\examples{
bind_all(1:5, 1:3, which = 'cbind')
bind_all(1:5, 1:3, which = 'rbind')

m1 <- matrix(1:4)
m2 <- matrix(1:4, 1)

cbindx(m1, m2)
rbindx(m1, m2)
rbindx(mtcars, m2)


## "stack" named vectors
f <- function(x) setNames(letters[x], LETTERS[x])
x <- lapply(list(1:5, 3:6, 2:7, 26), f)
do.call('rbindfill', x)

## "stack" matrices or data frames
colnames(m1) <- 'B'
colnames(m2) <- LETTERS[1:4]
rbindfill2(m1, m2)
rbindfill2(m2, m1)

set.seed(1)
dd <- matrix(NA, nrow = 1, ncol = 10)
dd <- as.data.frame(col(dd))
l <- setNames(lapply(1:5, function(x) dd[, sample(x), drop = FALSE]),
              letters[1:5])

Reduce('rbindfill2', l) ## or do.call('rbindfill2', l)
do.call('rbindfill2', c(l, use.rownames = TRUE))
rbindfill2(l$c, l$e)

rbindfill2(head(mtcars), head(cars))


## "stack" a list of vectors with differing lengths
rbindlist(1:5)
rbindlist(1:5, 1:5)

l <- lapply(1:4, sequence)
rbindlist(l)
rbindlist(l[4L])

names(l) <- LETTERS[1:4]
rbindlist(l)
rbindlist(l[4L])

l <- lapply(l, function(x) setNames(x, letters[x]))
rbindlist(l, use.names = TRUE)
rbindlist(unname(l), use.names = TRUE)


## unnest and stack a data frame or matrix
dd <- data.frame(
  id = 1:4, x = rnorm(4), y = sapply(l, toString),
  z = sapply(l, paste, collapse = '...')
)
rbindlist2(dd, 'y')

## rownames are kept if data contains non default rownames
rbindlist2(`rownames<-`(dd, letters[1:4]), 'y')

## multiple columns can be expanded sequentially
rbindlist2(dd, c('y', 'z'))
rbindlist2(dd, 'y', split = '\\\\W+(?![^3]+3)', perl = TRUE)

}
\seealso{
\code{\link{cbind}}; \code{\link{rbind}}; \code{\link{interleave}};
\code{\link[rawr2]{clist}}; \pkg{qpcR}
}
