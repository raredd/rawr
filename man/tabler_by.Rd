% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils2.R
\name{tabler_by}
\alias{tabler_by}
\alias{tabler_by2}
\title{tabler_by}
\usage{
tabler_by(
  data,
  varname,
  byvar,
  n = NULL,
  order = FALSE,
  zeros = TRUE,
  pct = FALSE,
  pct.column = FALSE,
  pct.total = FALSE,
  pct.sign = FALSE,
  drop = TRUE
)

tabler_by2(
  data,
  varname,
  byvar,
  n = NULL,
  order = FALSE,
  stratvar = NULL,
  zeros = TRUE,
  pct = FALSE,
  pct.column = FALSE,
  pct.total = FALSE,
  pct.sign = TRUE,
  drop = TRUE,
  collapse_varname = FALSE,
  collapse_format = c("<b>\%s</b>", "\%s")
)
}
\arguments{
\item{data}{a data frame; variables \code{varname} and \code{byvar} should
be factors}

\item{varname}{subgroup variable name (rows)}

\item{byvar}{stratification variable name (columns)}

\item{n}{number in each group; see details}

\item{order}{logical; order the result by decreasing frequency}

\item{zeros}{optional character string replacement for cells which have
zero counts; will appear as \code{0 (0\%)} if \code{TRUE}}

\item{pct}{logical; if \code{TRUE} (and \code{n} is not missing), percents
are shown}

\item{pct.column}{logical; if \code{TRUE}, percents are separated into new
columns}

\item{pct.total}{logical; if \code{TRUE}, adds percents for total column}

\item{pct.sign}{logical; if \code{TRUE}, percent sign is shown; otherwise,
percents are shown in parens without sign}

\item{drop}{logical; for \code{tabler_by} if \code{TRUE}, rows or columns
with zero total counts will be removed (default); the \code{FALSE} case is
useful when merging multiple \code{tabler_by} tables (e.g., this is how
\code{tabler_by2} aligns stratified tables)}

\item{stratvar}{for \code{tabler_by2}, a factor-like variable used to
stratify observations into mutually exclusive groups for which
\code{tabler_by} will be performed on each subset}

\item{collapse_varname}{logical; for \code{tabler_by2}, combine multiple
\code{varname}s into a single column with indents and extra rows for
headers}

\item{collapse_format}{format strings for headers and normal rows,
respectively, passed to \code{\link{sprintf}}}
}
\description{
This function is helpful for making simple, formatted tables similar to
the functionality of \code{\link[tables]{tabular}}.

\code{tabler_by} creates simple tables, and \code{tabler_by2} is a wrapper
which can create stratified tables (\code{tabler_by} can also achieve this
but requires additional steps).
}
\details{
\code{varname} and \code{byvar} should be factors, and the levels will
appear in the output as they occur in \code{levels(x)}.

\code{n} is used to calculate the percent. If missing, the output will
only show counts in the table. If given, \code{length(n)} should be one or
equal to the number of levels of \code{byvar}.

If one \code{n} is given, \code{tabler_by} assumes that this is the total
population for a subgroup, e.g., if creating a table for a subset of the
data, it is only necessary to provide the total \code{n} for that group.

If more than one \code{n} is given, \code{tabler_by} assumes that the
entire data set is given as \code{data} and will use the corresponding
\code{n} for percents.
}
\examples{
mt <- within(mtcars, {
  am   <- factor(am)
  gear <- factor(gear)
  vs   <- factor(vs, 0:2)
  vs2  <- factor(vs, 2:0)
  carb <- factor(carb)
})

tabler_by(mt, 'vs', 'gear')
tabler_by(mt, c('vs2', 'carb'), 'gear', order = FALSE)
tabler_by(mt, c('vs2', 'carb'), 'gear', order = TRUE)


## when length(n) > 1, each column uses a different n for percents
tabler_by(mt, 'vs', 'gear', n = 32, pct = TRUE)
tabler_by(mt, 'vs', 'gear', n = table(mt$gear), pct = TRUE)
tabler_by(mt, 'vs', 'gear', n = table(mt$gear), zeros = '-',
          pct = TRUE, pct.column = TRUE, pct.total = TRUE)


## use tabler_by2 to create a stratified table
t1 <- tabler_by2(mt, c('vs', 'carb'), 'gear', stratvar = 'am', order = TRUE)

## or tabler_by to do this in several steps
t2 <- cbind(
  tabler_by(mt, varname = c('vs', 'carb'), byvar = 'gear',
            drop = FALSE)[, c('carb', 'Total')],
  tabler_by(mt[mt$am == 0, ], varname = c('vs', 'carb'), byvar = 'gear',
            drop = FALSE)[, -1],
  tabler_by(mt[mt$am == 1, ], varname = c('vs', 'carb'), byvar = 'gear',
            drop = FALSE)[, -1]
)

## order, drop extra rows/columns, set rownames
rownames(t2) <- locf(rownames(t2))
t2 <- t2[order(locf(rownames(t2)), -xtfrm(t2[, 2])), ]
t2 <- t2[!t2[, 'Total'] \%in\% '0', ]
t2 <- t2[, apply(t2, 2, function(x) !all(x \%in\% '0'))]
rownames(t2)[duplicated(rownames(t2))] <- ''

stopifnot(identical(t1, t2))


## example workflow
set.seed(1)
f <- function(x, ...) sample(x, 100, replace = TRUE, ...)
tox <- data.frame(
  id = rep(1:10, 10), phase = 1:2,
  code = f(rawr::ctcae_v4$tox_code[1:100]),
  grade = f(1:3, prob = c(0.6, 0.3, 0.1))
)

tox <- cbind(tox, match_ctc(tox$code)[, c('tox_cat', 'tox_desc')])

## get worst toxicities by id, by grade
n <- colSums(table(tox$id, tox$phase) > 0)
tox[] <- lapply(tox, factor)
tox <- tox_worst(tox, desc = 'tox_desc')

out <- tabler_by2(tox, 'tox_desc', 'grade', stratvar = 'phase', zeros = '-')
colnames(out)[1] <- sprintf('Total<br /><font size=1>n = \%s</font>', sum(n))
cgroup <- c(
  '',
  sprintf('Phase I<br /><font size=1>n = \%s</font>', n[1]),
  sprintf('Phase II<br /><font size=1>n = \%s</font>', n[2])
)

htmlTable::htmlTable(
  out, ctable = TRUE, cgroup = cgroup, n.cgroup = c(1, 4, 4),
  caption = 'Table 1: Toxicities<sup>&dagger;</sup> by phase and grade,
            sorted by total.',
  col.columns = rep(c('grey97', 'none', 'grey97'), times = c(1, 4, 4)),
  col.rgroup = rep(rep(c('none', 'grey97'), each = 5), 10),
  tfoot = paste0('<font size=1><sup>&dagger;</sup>Percents represent ',
           'proportion of patients out of respective phase total.</font>')
)


## same as above but add level of stratification, sort by total within group
out2 <- tabler_by2(tox, c('tox_cat', 'tox_desc'), 'grade', order = TRUE,
                   stratvar = 'phase', zeros = '-', n = c(5, 5), pct = TRUE)
stopifnot(
  identical(
    sort(unname(out[, grep('Total', colnames(out))[1]])),
    sort(unname(out2[, grep('Total', colnames(out2))[1]]))
))

colnames(out2)[1:2] <- c(
  'Description', sprintf('Total<br /><font size=1>n = \%s</font>', sum(n))
)

cgroup <- c(
  '', '',
  sprintf('Phase I<br /><font size=1>n = \%s</font>', n[1]),
  sprintf('Phase II<br /><font size=1>n = \%s</font>', n[2])
)

htmlTable::htmlTable(
  out2, align = 'lc', cgroup = cgroup, n.cgroup = c(1, 1, 4, 4),
  caption = 'Table 1: Toxicities<sup>&dagger;</sup> by category, phase,
  grade.'
)


## collapse varname columns into single column with indents/extra rows
out3 <- tabler_by2(
  tox, c('tox_cat', 'tox_desc'), 'grade', stratvar = 'phase', zeros = '-',
  n = c(5, 5), pct = TRUE, pct.sign = FALSE,
  collapse_varname = TRUE, collapse_format = c('<i>\%s</i>', '&emsp;\%s')
)

htmlTable::htmlTable(
  out3, align = 'c', cgroup = cgroup[-1], n.cgroup = c(1, 1, 4, 4)[-1],
  caption = 'Table 1: Toxicities<sup>&dagger;</sup> by category, phase,
  grade.'
)

}
\seealso{
\code{\link{tox_worst}}; \code{\link{match_ctc}}

Other tabler: 
\code{\link{tabler}()},
\code{\link{tabler_resp}()},
\code{\link{tabler_stat}()},
\code{\link{tabler_stat2}()}
}
\concept{tabler}
